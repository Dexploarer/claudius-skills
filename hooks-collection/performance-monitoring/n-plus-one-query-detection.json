{
  "name": "n-plus-one-query-detection",
  "event": "user-prompt-submit",
  "description": "Detects N+1 query problems in database code",
  "enabled": true,
  "prompt": "Before committing database query code, scan for N+1 query patterns:\n\n**Anti-Patterns to Detect:**\n\n1. **Loop with queries**\n```python\n# âŒ N+1 problem\nusers = User.query.all()\nfor user in users:\n    posts = Post.query.filter_by(user_id=user.id).all()  # N queries!\n```\n\n2. **Lazy loading in loops**\n```javascript\n// âŒ N+1 problem\nconst users = await User.findAll();\nfor (const user of users) {\n  const posts = await user.getPosts();  // N queries!\n}\n```\n\n3. **Resolver without DataLoader**\n```javascript\n// âŒ N+1 problem (GraphQL)\nconst resolvers = {\n  User: {\n    posts: (user) => Post.find({ userId: user.id })  // N queries!\n  }\n};\n```\n\n**If N+1 Detected:**\n\n```\nðŸš¨ N+1 QUERY PROBLEM DETECTED\n\nFile: src/api/users.py\nLines: 45-47\n\nCode:\n```python\nusers = db.query(User).all()  # 1 query\nfor user in users:\n    user.posts = db.query(Post).filter(Post.user_id == user.id).all()  # N queries\n```\n\nProblem:\nâ€¢ 1 query to fetch users\nâ€¢ N queries to fetch posts (one per user)\nâ€¢ For 100 users: 101 database queries!\n\nPerformance Impact:\nâ€¢ 100 users: ~500ms\nâ€¢ 1,000 users: ~5s\nâ€¢ 10,000 users: ~50s\n\nOptimized Solution:\n```python\n# âœ… Use eager loading\nusers = db.query(User).options(\n    joinedload(User.posts)\n).all()  # Just 1 query with JOIN!\n\n# OR use separate query\nusers = db.query(User).all()\nuser_ids = [u.id for u in users]\nposts = db.query(Post).filter(Post.user_id.in_(user_ids)).all()\n# Group posts by user_id\n```\n\nFor GraphQL:\n```javascript\n// âœ… Use DataLoader\nconst postLoader = new DataLoader(async (userIds) => {\n  const posts = await Post.find({ userId: { $in: userIds } });\n  // Return posts grouped by userId\n});\n\nconst resolvers = {\n  User: {\n    posts: (user) => postLoader.load(user.id)\n  }\n};\n```\n\nORM-Specific Solutions:\nâ€¢ Django: select_related(), prefetch_related()\nâ€¢ SQLAlchemy: joinedload(), subqueryload()\nâ€¢ Sequelize: include option\nâ€¢ TypeORM: relations in find()\nâ€¢ Prisma: include option\n\nQuery Optimization Checklist:\n[ ] Use eager loading for relationships\n[ ] Batch queries when possible\n[ ] Add DataLoader for GraphQL\n[ ] Index foreign keys\n[ ] Profile query performance\n\nEstimated Performance Gain:\nâ€¢ Before: 101 queries, ~500ms\nâ€¢ After: 1-2 queries, ~50ms\nâ€¢ 10x faster! ðŸš€\n\nApply fix automatically? (yes/no/show-diff)\n```"
}
